# [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例:**

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

#### 1.解题思路

本题的解题思路跟62题类似，由于本题没有给出图片，我们自己画了一幅图，左边的二维数组是原始路径以及路径上的数字，右边的二维数组是我们自己定义的二维数组，保存到每个节点最小路径数。

![](https://github.com/121880399/leetcode_training_camp/blob/master/wiki/t64/1.png)

本题要求的是路径上数字总和为最小，而每次移动都只能右移和下移。我们很容易就想到，到某个节点路径上的数字最小，应该是从上方或者左方到达该节点数字较小的那一个加上本节点上的数字。以上图举例，到达第一行第一列路径上数字的最小和就是第0行第1列和第1行第0列中较小的数字加上当前节点的数字。

#### 2.定义

dp[i] [j]:到达第i行第j列是，路径上数字总和最小值

#### 3.方程

dp[i] [j] = min(dp[i-1] [j],[i] [j-1])+arr[i] [j]

#### 4.代码实现

```java
public int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int [][]dp = new int[m][n];
    //初始化dp[0][0]
    dp[0][0] = grid[0][0];
    //初始化第一列
    for(int i=1;i<m;i++){
        dp[i][0]=dp[i-1][0]+grid[i][0];
    }
    //初始化第一行
    for(int j=1;j<n;j++){
        dp[0][j]=dp[0][j-1]+grid[0][j];
    }
    for(int i=1;i<m;i++){
        for(int j=1;j<n;j++){
            dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
        }
    }
    return dp[m-1][n-1];
}
```

#### 5.优化

本题跟62题优化思路一样，都是把二维数组转换为一维数组来降低空间复杂度。我们只保存一行的数据，每次都更新它的值。

#### 6.代码实现

```java
/**
* 降低空间复杂度
 * 使用一位数组记录一行的数据
 * 不断的更新一维数组中的值
* 作者: ZhouZhengyi
* 创建时间: 2020/4/20 23:52
*/
public int betterMinPathSum(int[][] grid) {
    //得到行数
    int m = grid.length;
    //得到列数
    int n = grid[0].length;
    //创建一维数组
    int []dp = new int[n];
    //初始化dp[0]
    dp[0] = grid[0][0];
    //初始化第一行
    for(int j=1;j<n;j++){
        //第一行的所有值都是前一列的最小路径和加上本身的数字
        dp[j]=dp[j-1]+grid[0][j];
    }
    for(int i=1;i<m;i++){
        //等式右边的dp[0]是上一行的第0列最小路径和，等式左边的dp[0]是当前行第0列的值
        dp[0] = dp[0]+grid[i][0];
        for(int j=1;j<n;j++){
            dp[j] = Math.min(dp[j],dp[j-1])+grid[i][j];
        }
    }
    return dp[n-1];
}
```

本题将二维数组转换为一维数组以后状态转移方程没有改变，只是使用了一维数组来操作，都是用上一行的值来更新本行的值。