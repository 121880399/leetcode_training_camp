# [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明:**

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。

- 你算法的时间复杂度应该为 O(*n2*) 。

#### 1.解题思路

​	这一题可能一上来找不到思路，但是这题又确实很简单，找不到思路是因为这题很容易让人多想，因为这题会有很多的分叉，让你感觉找到了方向，结果答案是错误的，原因还是思维不严谨，或者逻辑不够清晰。这里列举一种容易错想的思维：

​	选或者不选，做过动态规划题的童靴都会有这种思维，这个数，我选它是几种可能，不选它是几种可能，那么我取最大的不就行了吗？举例，定义dp[i]为到第i个元素时，最长上升子序列数。那么dp[i]=max{max(dp[j])+1,dp[i-1]},这个意思就是第i个元素时，最长上升子序列数等于选它或不选它的最大值，选它的值等于i之前的最大子序列数+1,不选的话最长子序列数就应该是前面一个数的最长子序列数。这逻辑看似没毛病，实际上如果不选这个数，最长子序列数真的应该是前一个数的最长子序列数吗？如果i的位置是最后一个元素，那么这种思维没毛病，但是如果i不是最后一个数，问题就来了。举例{1,3,6,7,9,4,10,5,6}，这串数组，从数字1到数字9的最长子序列分别是{1,2,3,4,5}在这里没有争议，我们看到数字4的时候，我们发现如果按照选与不选的思维，dp[i]=max{max(dp[j])+1,dp[i-1]}=5，最后4记录的最长子序列是5，如果4这个元素是数组最后一个元素，那么没毛病，这题最长子序列就是5，但是数字4并不是最后一个元素，我们接着往下看，当到数字10的时候，最长子序列是6，到数字5的时候，如果选择5这个数字，那么我们要从5前面所有小于它的数字中去查找最长子序列，我们这时候发现数字4这个位置的最长子序列是5，那么按照刚刚的公式5+1=6，如果不选的话是前面一个数字的最长子序列也是6。到数字6的时候一样会查找前面小于它的数字的最长子序列，那就是数字5保存的最长子序列6，那么6+1=7，不选的话是6，最后综合起来最大值是7。这时候就出错了，因为最长子序列只能是{1,3,6,7,9,10}只有6个，而不是7个。问题出在了哪？按照我们对dp[i]的定义，这种思维没毛病啊。问题就出在了对dp[i]的定义上，我们是否真的要关注不选？我们能不能只关注选择的情况。从上个例子来说，因为在数字4的时候，不选的值大于选的值，导致4最后的取值是不选的值5，而这个值又进而影响到了后面的数字5，数字5又影响到了数字6的结果。如果我们在数字4时不考虑不选它的情况，只考虑选择的情况，那么4的取值应该是3，数字5的取值应该是4，数字6的取值应该是5。最后整串数字最长子序列是数字10所记录的6。所以我们对dp[i]的定义应该是当选了第i个值是，从0-i的位置最长子序列是多少。我们没必要在第i个位置上去关心不选的情况。

#### 2.定义

```
dp[i]:选上i以后，从0-i最长子序列长度。
```

​	这里要注意区分，不是到i为止，最大子序列长度。而是要选上i以后最大子序列长度。比如【4，10，4】,i=2,dp[2]=1，也就是选上4以后，前面并没有比4小的，所以最大子序列为1。就算i=2之前已经有最大子序列【4，10】了，但是【4，10】后面不能选4。还要注意，不是在i之前小于nums[i]的数一共有多少个。例如【4，10，4，3，8，9】，i=4 nums[4]=8,在i=4之前有3个数都小于8,并不意味着dp[4]=4，能与8构成最长子序列的最大长度只有2，所以dp[4]=2。

#### 3.方程

```
dp[i]=max{dp[i],dp[j]+1},其中j[0,i-1]且nums[j]<nums[i]。
```

#### 4.初始值
```
​	dp[0,n-1]=1，从[0,n-1]每个数字最长子序列初始值只有自己，所以全是1。
```
#### 5.代码实现

```java
public int lengthOfLIS(int[] nums) {
        if(nums.length <= 0){
            return 0;
        }
        //如果给定数组不为空，那么最长上升子序列最少是1
        int result = 1;
        //用于存放给定数值下标对应的最长子序列个数
        int[] dp = new int[nums.length];
        for(int i=0;i<nums.length;i++){
            //全部设置默认值为1，因为就算是倒序的情况下，每个位置对应的最长序列个数也为1
            dp[i]=1;
        }

        for(int i=1;i<nums.length;i++){
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    //如果i所在位置的数大于j所在位置的数,说明存在升序
                    //确保dp[i]的值是i之前所有小于Nums[j]的数中，最大子序列数+1的值与默认值1之间的最大值
                    dp[i] = Math.max(dp[i],dp[j]+1);
                }
            }
            //把最大上升子序列数与当前i位置得到的最大上升子序列数相比，保存最大值
            result = Math.max(result,dp[i]);
        }
        System.out.print(Arrays.toString(dp));
        return result;
    }
```

代码实现还是比较清晰的，首先定义一个一维数组用来保存每个位置对应的最长子序列数，并且赋予初始值1。然后遍历nums数组,更新每个位置的最长子序列数，当前位置的最长子序列数等于在它之前的所有小于它的数的最长子序列数最大值+1。最后用一个变量result来记录整个数组最大的最长子序列数就行。