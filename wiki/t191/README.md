# [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。

示例 1：

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

示例 2：

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```


示例 3：

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

提示：

```
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
```



#### 1.解题思路

本题出现了关键字二进制，那说明很有可能是考察二进制的位运算能力，如果从这个角度来思考，我们很容易想到，每次取最低位，然后判断是否为1，如果为1则统计加1，这样最后就能得到所给定的数字的二进制有多少个1。



#### 2.代码实现

```java
/**
    * 方法1：每次截取最后一位，判断是否
     * 为1。
    * 作者: ZhouZhengyi
    * 创建时间: 2020/5/22 9:22
    */
    public static int hammingWeight(int n) {
        int num=0;
        //n的二进制有可能很大，导致n是一个负数，所以这里不能使用
        //n>0,比如n的二进制位为11111111111111111111111111111101
        while(n != 0) {
            if ((n & 1) == 1) {
                num++;
            }
            n = n >>> 1;
        }
        return num;
    }
```

我们使用&操作符，&操作符有个特定，就是跟1进行与操作，所得到的值等于它的本身。

```
比如：
  11001110
& 00000001
------------
  00000000
例2：
  11001101
& 00000001
--------------
  000000001
  
```

所以我们可以通过与1来得到最后一位，再判断是否为1。

这里我发现网上有这种写法的，尽量面试的时候不要这样写。

```java
public int hammingWeight(int n) {
        String str = Integer.toBinaryString(n);
        int count=0;
        for(int i=0;i<str.length();i++){
            if(str.charAt(i)=='1')
                count++;
        }
        return count;
    }
```

他这里先把n转换为string类型，然后再每次取一个字符判断是否为1。这样就偏离了考察的目的了，既然都这样写了，为啥不直接调用bitCount（）方法呢？

```java
public int hammingWeight(int n) {
        return Integer.bitCount(n);
    }
```

小盆友，你是否有很多问号？没错，Integer类已经实现了这个功能，我们来看一下它是如何实现的。

```java
public static int bitCount(int i) {
        // HD, Figure 5-2
        i = i - ((i >>> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 0x3f;
    }
```

是不是也一脸蒙蔽呀？我们来看一下简化版本的。

```java
  /**
    * 方法2：采用分组的方式，每次统计一组中1的个数
     * 然后一直合并，最终得到1的个数。
    * 作者: ZhouZhengyi
    * 创建时间: 2020/5/22 10:17
    */
    public static int other(int n){
        //每1位为一组
        //0101的16进制为5 int一共32位，一共有8组0101
        //所以有8个5
        int m_1 = 0x55555555;
        //每2位为一组 0011的16进制为3
        int m_2 = 0x33333333;
        //每4位为一组 00001111的16进制为0f
        int m_4 = 0x0f0f0f0f;
        //每8位为一组 0000000011111111的16进制为00ff
        int m_8 = 0x00ff00ff;
        //每16位为一组 00000000000000001111111111111111的16进制为0000ffff
        int m_16 =0x0000ffff;

        //n与m_1做与运算，得到每组最右边的数
        //再将n右移一位跟m_1做与运算，得到每组最左边的数
        //将得到的两个数相加
        int a = (n & m_1) + ((n>>>1) & m_1);
        int b = (a & m_2) + ((a>>>2) & m_2);
        int c = (b & m_4) + ((b>>>4) & m_4);
        int d = (c & m_8) + ((c>>>8) & m_8);
        int e = (d & m_16) + ((d>>>16) & m_16);
        return e;
    }
```

这种解法的思路就是分组，有点类似于归并算法，两两分组，如何合并。但是这种算法面试的时候你不一定第一时间能想到，所以能理解就行。



