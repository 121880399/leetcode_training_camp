# [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

说明：

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

#### 1.解题思路

​	这题其实很简单，关键在于搞清楚规则，题目给出的规则信息很少，如果规则没搞清楚就容易多想。首先要明确什么叫相邻节点？比如第i行第j个元素，那么它的下一行相邻节点就是[i+1] [j]和[i+1] [j+1]。其次要搞清楚给定的这个三角形行数跟列数是一致的，比如有4行，那么就一定有4列。搞清楚这两点以后，讨论一下解本道题的方法，首先一种想法就是通过递归，得到所有路径上的值，然后找出最小的来。还可以通过动态规划来解题，这里我们采用动态规划的方式来解题，注意这题很容易陷入一个误区，就是使用贪心算法，最恐怖的就是给出的示例三角形使用贪心算法是可行的，但是稍微改动一下三角形的值就会出错，比如以下三角形。

```
[
     [2],
    [3,1],
   [6,5,4],
  [4,1,19,32]
]
```

贪心算法就是每次都选择最优解，但是最后的结果未必是最优的，比如上面这个三角形，路径肯定是从2->1->4>19,我们发现在做每次选择的时候都选的最优的结果，最后的结果却不是最优的。

​	这题要是用动态规划来解，还需要一个注意的地方，就是必须从下往上倒推。至于为什么，后面会说到。

#### 2.定义

```
dp[i][j]:从下往上到第i行第j个元素时可选路径中最小路径和
```

怎么理解这个定义呢？比如示例中dp[2] [0]元素，从第3行能到达它的只有4和1两个值。那么dp[2] [0]的值就是1+6=7。至于第3行的8和3两个数，是不能够到达它的，所以不用考虑。

#### 3.方程

```
dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+arr[j];
```

状态转移方程很简单，通过定义我们就可以推出来，dp[i] [j]的值肯定是它下面那一行能到达它的两个数路径和中最小的那个加上本身的数值。

#### 4.代码实现

```java
public int minimumTotal(List<List<Integer>> triangle) {
    if(triangle == null || triangle.size()==0){
        return 0;
    }
    //这个三角形行数跟列数是相等的
    int n = triangle.size();
    int [][]dp = new int[n][n];
    //初始化最后一行
    List<Integer> lastRow = triangle.get(n-1);
    for(int j=0;j<n;j++){
        dp[n-1][j]=lastRow.get(j);
    }
    for(int i = n-2;i>=0;i--){
        List<Integer> row = triangle.get(i);
        for(int j=0;j<row.size();j++){
            dp[i][j]=Math.min(dp[i+1][j],dp[i+1][j+1])+row.get(j);
        }
    }
    return dp[0][0];
}
```

代码实现很简单，我们主要讲一下为什么要从下往上倒推，如果我们从上往下推会出现什么问题，比如现在dp[1] [1],它的值应该是它上一行能够到达它的路径和中最小的那一个，也就是dp[0] [0]和dp[0] [1]，这时候最小的肯定是dp[0] [1],因为它的值是0，并且我们发现规则变成了dp[i] [j]=min(dp[i-1] [j-1],dp[i-1] [j])。除非我们手动的控制第1行的赋值只能取第0行的第0位元素，这样的话就要单独处理太麻烦了，还有更麻烦的,当dp[1] [0]时，由于规则的改变，需要取dp[i-1] [j-1]的值，我们就发现下标越界了，所以我们还得处理越界问题。由此看来，不能从上往下推算，从这里我们也能看出，使用动态规划，最后的结果一定是收敛的，而从上往下推是发散的，就算能够推算成功，最后还需要遍历最后一行找出最小值。

#### 5.优化

从以上代码我们可以发现，其实我们没必要记录所有行的值，我们只需要记录一行的值就行，所以可以把二维数组转换为一维数组。

#### 6.代码实现

```java
/**
* 采用一维数组来存储，降低空间复杂度
* 作者: ZhouZhengyi
* 创建时间: 2020/4/22 17:28
*/
public int betterMinimumTotal(List<List<Integer>> triangle){
    if(triangle == null || triangle.size()==0){
        return 0;
    }
    int n = triangle.size();
    int [] dp = new int[n+1];

    for(int i = n-1;i>=0;i--){
        List<Integer> row = triangle.get(i);
        for(int j=0;j<row.size();j++){
      //把最后一行的初始化也统一到了这里，因为最后一行没有dp[j+1],为了保证数组不越界，只能在申请大小时加一
            dp[j] = Math.min(dp[j],dp[j+1])+row.get(j);
        }
    }
    return dp[0];
}
```

代码更简洁了，空间复杂度也降低了。