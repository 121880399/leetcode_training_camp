# [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```



#### 1.解题思路

每次只能爬1个或者2个台阶，假设现在只有3阶台阶，那么爬3阶台阶的方法只能第一阶台阶爬法总数加上第二阶台阶的爬法总数，也就是只有3种爬法。那么就可以推出第i阶台阶的爬法总数等于它前面两台阶的爬法总数相加。

#### 2.定义

dp[i]:第i阶台阶的爬法总数

#### 3.方程

dp[i]=dp[i-1]+dp[i-2]

也就是第i阶台阶的爬法总数等于i-1阶的爬法总数加上i-2阶的爬法总数。

#### 4.初始值

dp[1]=1， dp[2]=2  

第一阶的爬法只能有一种

第二阶的爬法只能有两种

#### 5.代码实现

```java
/**
* 利用数组来记录
* 作者: ZhouZhengyi
* 创建时间: 2020/4/20 9:58
*/
public int climbStairs(int n) {
    //两阶以下的台阶爬法跟台阶数一样
    if(n <= 2){
        return n;
    }
    int [] dp = new int[n+1];
    //设置初始值
    dp[1] = 1;
    dp[2] = 2;
    for(int i=3; i<dp.length;i++){
        //第i阶台阶的爬法等于i-1阶加上i-2阶
        dp[i] = dp[i-1]+dp[i-2];
    }
    return dp[n];
}
```

这种方法直观简单，容易理解，但是空间复杂度太高了，能不能把空间复杂度降下来？目前n个数，就要申请n+1个空间。我们真的需要这么多空间吗？可以发现第n阶台阶的爬法只是跟前面两阶有关系，跟n-2阶前面的台阶数没关系，所以我们只需要记录前面两阶的台阶总数就行。

```java
/**
* 降低空间复杂度，从O(n)->O(1)
* 作者: ZhouZhengyi
* 创建时间: 2020/4/20 10:00
*/
public int betterClimbStairs(int n){
    //小于2阶台阶，走法跟台阶数一样
    if(n <= 2){
        return n;
    }
    //能执行到这，说明最少3阶台阶
    //表示前面一阶台阶，3阶前面一阶台阶的走法一定是2
    int preOne = 2;
    //表示前面两阶台阶，3阶前面两阶的走法一定是1
    int preTwo = 1;
    //总的走法
    int total = 0;
    for(int i = 2; i < n ; i++){
        total = preOne + preTwo;
        preTwo = preOne;
        preOne = total;
    }
    return total;
}
```

preOne用来记录前面一阶台阶的爬法总数，preTwo用来记录前面两阶台阶的爬法总数,total用来记录当前台阶的爬法总数。每增加一阶台阶，当前台阶的爬法数就变成了前一阶的爬法数，preOne=total。前一阶的爬法总数就变成了前两阶的爬法总数，preTwo = preOne。这样就只需要3个变量就能得到n阶台阶的爬法总数。

#### 6.总结

这类型题目还是比较简单的，因为第n个值的结构很明显的与前面的几个数有关系，能够快速推导出方程，并且这类求几种的题目，一般都是每一种方法的结果相加。