# [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

示例 1:

```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。

1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```


示例 2:

```
输入: m = 7, n = 3
输出: 28
```

提示：

```
1 <= m, n <= 100
题目数据保证答案小于等于 2 * 10 ^ 9
```

#### 1.解题思路

本题给的图有点大，咱们可以把图缩小了来分析。如果有一个3行3列的图，从左上角到右下角移动，只能左移和右移，总共有多少条不同路径？

![](https://github.com/121880399/leetcode_training_camp/blob/master/wiki/t62/1.png)

因为每次只能往下或者往右移动一步，所以第一行只能有一条路径，第一列也只能有一条路径。以第2行第2列为例，到达第2行第2列的路径只能是第1行第2列和第2行第1列，也就是他上边和左边,所以到达第2行第2列共有6条不同路径。于是我们发现了规律，第i行第j列的值就等于第i-1行第j列的值加上第i行第j-1列的值。

#### 2.定义

dp[i] [j] ：第i行第j列同有多少条不同路径

#### 3.方程

dp[i] [j] =dp[i-1] [j]+dp[i] [j-1]  

#### 4.代码实现

```java
public int uniquePaths(int m, int n) {
    int [][] dp = new int[m][n];
    //初始化第一行和第一列
    for(int i=0;i<m;i++){
        dp[i][0]=1;
    }
    for(int j=0;j<n;j++){
        dp[0][j]=1;
    }
    for(int i=1;i<m;i++){
        for(int j=1;j<n;j++){
            dp[i][j]=dp[i-1][j]+dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
}
```

#### 5.优化

虽然使用二维数组保存数据，我们容易理解，但是毕竟增加了空间复杂度，我们能不能降低空间复杂度呢？我们观察一下，我们每一行数据进行赋值时，只需要前面一行的数据支持，那么我们是否可以用一维数组来存储一行的数据，每次更新对齐进行更新，一直到最后一行，我们返回最后一行的最后一个元素。

#### 6.代码实现

```java
/**
* 降低空间复杂度
 * 我们发现，当前行的值，只有上一行的值有关系
 * 所以我们就打算只用一个一维数组来存储
* 作者: ZhouZhengyi
* 创建时间: 2020/4/20 22:11
*/
public int betterUniquePaths(int m,int n){
    int [] dp = new int[n];
    //初始化
    for(int j=0;j<n;j++){
        //第一行全为1
        dp[j]=1;
    }
    //从第二个行开始赋值
    for(int i=1;i<m;i++){
        //每一行的第一个值
        dp[0]=1;
        for(int j=1;j<n;j++){
            //更新dp[j]的值，等式右边的dp[j]是上一行同一列的值，等式左边是当前行当前列的值
            dp[j] = dp[j-1]+dp[j];
        }
    }
    return dp[n-1];
}
```

这时候的状态转移方程发生了改变。dp[j] = dp[j-1]+dp[j];等式右边的dp[j]是上一行同一列的值，等式左边是当前行当前列的值。我们用上一行当前列的值与当前行前一列的值来更新当前行当前列的数据。这样我们就把二维数组降级成了一维数组。