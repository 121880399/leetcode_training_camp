# [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。

示例 1:

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

示例 2:

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

示例3：

```
输入: [-9,1,-9]
输出: 81
```

示例4：

```
输入: [0,2]
输出: 2
```

示例5：

```
输入: [-1, -2, -9, -6]
输出: 108
```

#### 1.解题思路

本题给的示例不是特别好，所以我又自己加了几个示例。增加的后面3个示例能让你在分析的时候考虑的更全面一些。本题要是用递归把选或者不选都计算出来，也能解题。但是这里采用动态规划来解题。如果只看示例1和示例2，你可能会说，这么简单的题目，根本不需要什么动态规划，我只要从数组小标0开始，一直累积乘后的结果，取最大值一样能够做出这道题,比如：

```java
int sum=nums[0];
int max=sum;
for(int i=1;i<nums.length;i++){
	sum=sum*nums[i];
    max=Math.max(max,sum);
}
```

就这么几行代码就搞定了，不信你跑示例1和示例2，是不是都正确？你看着就是示例给的不好带来的弊端，也会让人进入误区。示例4就是最好的反例，按上面代码的逻辑示例4输出的结果是0，而实际的结果应该是2。于是你又意识到了什么，好像没考虑取当前数字的情况。于是你又修改了你的代码如下:

```java
int sum=nums[0];
int max=sum;
for(int i=1;i<nums.length;i++){
	sum=Math.max(sum*nums[i],nums[i]);
    max=Math.max(max,sum);
}
```

这下好了，取最大值就可以解决示例4的问题，sum*nums[i]=0,nums[i]=2，那么最后结果就是2了。但是问题又来了，上面这段代码确实解决了示例4，但是如果输入示例3你咋办？按照以上逻辑示例上的输出应该是1，但是实际上示例3的结果应该是81。这下你终于崩溃了，这也太难了。

​	静下心来分析后，你发现示例3中，问题出现在第二部，也就是数组下标为1的时候，你用(-9*1,1)取最大值，这时候取的是1，再接着执行(1 * -9,-9)取最大值，最大值为-9，总的最大值为1。但是在数组下标为1的时候，你取的是最小值，那么就是-9,再接着执行(-9* -9,-9)取最大值的时候，得到的就是81，最后总的最大值是81。这时候你意识到了，一会取最大值，一会取最小值，该怎么办？能不能同时保存最大值和最小值？什么时候取最大值？什么时候取最小值呢？自然可以多声明一个变量来存储最小值，关键在于什么时候取最小值，什么时候取最大值呢？我们来分析一下，假如我们同时有两个变量，一个变量记录当前最大值，一个变量记录当前最小值，在示例3中，一开始当前最大值和当前最小值都是-9，接着我们用当前最大值与1相乘，再取最大值，也就是max(-9*1,1)=1,用当前最小值与1相乘，再取最小值，也就是min(-9 * 1,1)=-9,这时候我们就同时有了最大值和最小值，我们再接着用当前最大值与-9相乘，取最大值，max（1*-9,-9）=-9，当前最小值与-9相乘，取最小值min(-9 * -9,-9)=-9。发现出问题了，取不到81了，问题出在哪？问题在于我们用一个正数去乘一个负数，并且去最大值，那么结果肯定是负数，max（正数*负数，负数）=负数。并且我们用一个负数跟负数相乘取最小值，那么结果还是一个负数，min(负数 *负数，负数)=负数。那么我们该怎么办？我们回想一下开始是怎么得到81的？是不是在数组小标1的时候，我们用的是最小值去乘-9并且取最大值的？那么我们能不能把最大值跟最小值交换一下再进行乘法？答案是可以，那为什么要交换呢？我们注意到我们接下来要乘的数-9是一个负数，这下我们就明白了，如果是负数的情况，我们就把最大值和最小值进行交换。那这种交换会不会有问题？这里我们的最大最小值是一正一负，如果是两正，或者两负呢？我们来看一下，如果是最大值是正数，最小值是正数，交换以后会是什么结果，我们把没交换之前的最大值叫正数1，最小值叫正数2，正数1>正数2。交换以后与负数相乘，max（正数2 *负数,负数)=负数，min(正数1 * 负数，负数)=负数，这么看都是负数，好像没什么区别，但是我们可以发现，交换跟不交换的区别在于，交换以后取最小值时得到的负数更小了，这才是当前最小的负数，如果不交换得到的最小值负数不是最小的，这就导致，接下来又是一个负数的情况下，得不到正确的最大值，文字说起来可能比较抽象，再说下去就要晕了，还是自己用代码调试一下吧。如果最大值和最小值都是负数的情况，比如最大值是-1，最小值是-9，不交换的情况下max(-1 * -9,-9)=9 min(-9 * -9 ,-9)=-9 ,交换的情况下max(-9 * -9，-9)=81 min(-1 * -9,-9)=-9 我们可以看到如果不交换，我们得到的最大值不是最大化的，所以必须交换。

#### 2.代码实现

```java
public int maxProduct(int[] nums) {
    //全局最大值
    int max = nums[0];
    //当前最大值,初始化为1是因为1乘以任何数都是对方本身
    int curMax = 1;
    //当前最小值
    int curMin = 1;
    int temp = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] < 0) {
            //小于零，说明要乘以负数，那么将当前最大值和最小值进行交换
            temp = curMax;
            curMax = curMin;
            curMin = temp;
        }
        curMax = Math.max(curMax * nums[i], nums[i]);
        curMin = Math.min(curMin * nums[i], nums[i]);
        max = Math.max(max, curMax);
    }
    return max;
}
```

想通了以后，代码总是那么的朴实无华，明天会怎样呢？洗洗睡吧。。。